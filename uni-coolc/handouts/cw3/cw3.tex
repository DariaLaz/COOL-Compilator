% vim: textwidth=0 nowrap
\newcommand{\doctitle}{Курсова Работа: Част Трета\\До вторник, 16. декември 2025 г. 23:59}

\input{../common/preamble}

\begin{document}

\maketitle
\thispagestyle{fancy}

\section{Обзор на курсовата работа}

Курсовата работа се състои от четири части, които съответстват на четирите основни фази на един компилатор---лексикален анализатор, синтактичен анализатор, семантичен анализатор и генератор на код.
Тук пропускаме фазата за оптимизации, понеже целта ни е да създадем възможно най-простия работещ компилатор.
Всяко задание води до създаването на работеща фаза на компилатора, която да може да взаимодейства с останалите фази.
Ще реализирате вашият компилатор на C++.

Първите две части от курсовата работа изискваха от вас да създадете \emph{лексикален} и \emph{синтактичен анализатор} за програмния език COOL.
Третата (тази) част от курсовата работа изисква от вас да създадете \emph{семантичен анализатор} за COOL.
С приключването на тази част от курсовата работа ще имате завършена ``предна част'' (frontend) на компилатора.
Ако една програма премине успешно първите три фази, значи тя е валидна COOL програма.
Това означава, че за нея може да се генерира (машинен) код.
Все пак няма гаранции, че няма да възникнат грешки по време на изпълнение, или че програмата върши каквато и да е полезна дейност. Генераторът за код е длъжен да добави проверки за евентуални грешки по време на изпълнение.

В тази част няма да използвате специален софтуерен инструмент, за разлика от предните части.
Заданието е да напишете програма на C++, която да извършва семантичен анализ за дадена програма на COOL.
Крайната цел е: програмата която напишете, да построява АСД на COOL програмата, което да включва правилния статичен тип за всеки израз в нея.

Следната документация ще ви бъде от полза по време на работа:

\begin{enumerate}
    \item \href{https://web.stanford.edu/class/cs143/materials/cool-manual.pdf}{Ръководството за COOL (на английски)}, особено раздел 12 -- Type Rules.
\end{enumerate}

Разрешено е да работите индивидуално или по двойки. Ако работите по двойки, всеки е длъжен да предаде общата работа поотделно.

\section{Процес на Работа}\label{sec:process}
\subsection{Сваляне и Пускане на Контейнер}

За да започнете работа, изтеглете последната версия на docker контейнера. Този път няма промени по контейнера, така че ако вече имате версия cw2 следните команди не са нужни.

\verbatimfont{\ttfamily}
\begin{verbatim}
  docker pull ghcr.io/aristotelis2002/uni-cool:cw2
  <cd to your work dir>
  docker run -it --name cc-cw3 -v "$(pwd):/home/student/my-code" \
    ghcr.io/aristotelis2002/uni-cool
\end{verbatim}

Обърнете внимание на това, че трябва да ползвате етикет на контейнера cw2-arm, вместо cw2, ако сте с ARM процесор (по-нов macbook компютър).
Ако вече имате работещ контейнер, достатъчно е да използвате docker start за да го достъпите:

\verbatimfont{\ttfamily}
\begin{verbatim}
  docker start -ai cc-cw2
\end{verbatim}

\subsection{Сваляне и Пускане на Шаблонен Код}
Свалете шаблона за тази част от курсовата работа и го копирайте в папка, в която ще работите.

\begin{verbatim}
  git clone https://github.com/Aristotelis2002/uni-coolc temp
  cp -r temp/cw3template cw3 && chmod -R g+w cw3
  cd cw3 && chmod +x ./tools/*.sh
\end{verbatim}

\noindent Шаблонът съдържа следните неща:

\begin{enumerate}
    \item папка tools, която съдържа инструменти за компилиране и тестване;
    \item папка tests, която съдържа тестовите файлове за оценяването;
    \item папка lib, която съдържа библиотека със служебните lexer и parser;
    \item папка include, която съдържа header за служебните lexer и parser; и
    \item папка src.
\end{enumerate}

В папка src този път има доста код.
Освен завършения drivers/SemanticsDriver.cpp и шаблонния semantics/CoolSemantics.cpp, в src/typed-ast има пълна реализация на типизирано АСД, което да използвате за тази част от курсовата работа.
Не сте длъжни да ползвате този код, но смятаме, че това драстично ще улесни задачата ви.

Кодът, който трябва да промените за това задание се намира във файла CoolSemantics.cpp в папката src/semantics.

Папката include освен header файловете за служебните lexer и parser също съдържа и header файлове за типизираното АСД, както и за CoolSemantics.h.
Организацията на шаблонния проект следва система на разделяне на .cpp от .h файловете.
Респективно, те живеят в папките src и include, които имат идентична структура от под-папки помежду си.
Не сте длъжни да спазвате тази структура, но в противен случай може да се сблъскате с проблеми при компилацията на проекта, който ще трябва сами да оправите.

След промяна по кода, рекомпилирайте семантичния анализатор чрез скрипта ``tools/build.sh''.
За да започнете, извикайте този скрипт преди да сте направили каквито и да е промени и потвърдете, че той успешно завършва.

\begin{verbatim}
student@b9404ee896a3:~/my-code/cw3$ ./tools/build.sh
-- The CXX compiler identification is GNU 13.3.0
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
[...]
[100%] Built target parser
\end{verbatim}

Шаблонното решение успешно минава 71 от тестовете.
За да проверите това, изпълнете tools/test-semantics.sh.

\begin{verbatim}
student@b9404ee896a3:~/my-code/cw3$ ./tools/test-semantics.sh
[...]
Total 71 out of 174 tests PASSED
\end{verbatim}

\noindent Това не означава, обаче, че оценяващият скрипт ще ви даде 40\% от оценката без никакво усилие :)

Този скрипт е доста приказлив, така че е добавена възможност да изпълнява само някои от тестовете, подвайки префикс на името на теста, който да се изпълни.
Така ./tools/test-semantics.sh 01 ще изпълни 10 теста -- 010, 011, 012, и т.н. до 019.

\section{Задание}

Заданието е да напишете програма на C++, която да извършва следните операции / семантични проверки за дадена програма на COOL:
\begin{enumerate}
    \item събиране на имената на класовете в програмата;
    \item построяване на графа на наследяване между класовете;
    \item проверка за цикли в графа на наследяване (дали графа е дърво);
    \item събиране на имената на атрибутите и методите във всеки клас;
    \item проверка дали методите се презаписват правилно;
    \item проверка на типовете според типовите правила; и
    \item построяване на типизирано АСД.
\end{enumerate}

\noindent Не е задължително операциите и проверките, които реализирате, да бъдат разделени точно по този начин.
Не е задължително операциите и проверките да са точно тези---може да решите да добавите други или да пропуснете някои от тези.

Крайната цел е, програмата която напишете, да построява АСД на програмата, което да включва правилния статичен тип за всеки израз в нея.
В случай на успех, семантичният анализатор трябва да отпечата ``Semantic check succeeded!''.
В случай на грешка, семантичният анализатор трябва да отпечатва нея, вместо АСД.

Пример за отпечатване на грешка е при анализа на следната програма:

\begin{verbatim}
class Foo inherits Bar { };
class Bar inherits Baz { };
class Baz inherits Bar { };
class Qux inherits Zap { };
class Zap inherits Qux { };
\end{verbatim}

\noindent за която семантичният анализатор трябва да отпечата:

\begin{verbatim}
Semantic check failed with 1 errors:
Detected 2 loops in the type hierarchy:
1) Bar <- Baz <-
2) Qux <- Zap <-
\end{verbatim}

Спецификацията на типовите правила е описана в \href{https://web.stanford.edu/class/cs143/materials/cool-manual.pdf}{Ръководството за COOL (на английски)}, раздел 12 -- Type Rules.
Спецификацията на грешките е вградена в тестовете, така че използвайте тях за да дефинирате правилните текстови низове и логика на генерирането им.

Кодът, който трябва да промените за това задание се намира във файла CoolSemantics.cpp в папката src/semantics.
Изискването е този код да изпълни всички семантични проверки описани по-горе, или по-общо: семантиката на езикът COOL, както е описана в ръководството за COOL.
Шаблонът съдържа достатъчно код, така че да можете да започнете итеративна работа.

Един начин да подходите към решението е да изпълнявате тестовете подред.
Ако някой тест не минава да промените решението си и да опитате пак, докато тестващия скрипт не даде резултат PASSED.
За повече информация, вижте предния раздел: Раздел \ref{sec:process}.

Преди да започнете работа, прочетете внимателно раздел 12 от ръководството.

Вашият семантичен анализатор трябва да е стабилен---трябва да приема всеки възможен вход.
Трябва да се погрижите в случай на грешка, програмата да завършва по безопасен начин.
Не е приемливо да се стига до crash-ове или segmentation fault.
Желателно е да отпечатвате всички възможни грешки, но оценяващата програма проверява само съвпадение в съобщението от първата грешка.
Това е така, понеже най-полезното докладване на грешки е отчасти субективна величина.

\textbf{За да е възможно автоматичното оценяване, изходът от вашия синтактичен анализатор трябва точно да съвпада с предоставените тестове.}
Вижте раздел \ref{sec:process} за повече информация как да компилирате и тествате решението си.
Изключението е, че в тестовете очакващи грешка, оценяващия скрипт проверява само първия ред.

\section{Общи Насоки}

\subsection{Visitor Pattern}\label{sec:visitor}

В предната част на курсовата работа представихме visitor pattern и как да го ползваме за обхождане на АСД генерирано от ANTLR4.
Тук ще преговорим основните аспекти, които са ни нужни за реализацията на семантичен анализатор.

В режим \texttt{-visitor}, за всеки нетерминал, ANTLR4 генерира функция visit функция.
Ако граматиката ви се казва Foo.g4, тогава се генерира и клас FooBaseVisitor, който съдържа тези visit методи.
Основната част от работата ви, ще бъде да реализирате алгоритъм за проверка на типовете.
Това може да направите чрез клас наследяващ генерирания BaseVisitor.
Шаблонният код съдържа първоначална дефиниция на този клас -- TypeChecker.

Може да променяте TypeChecker както пожелаете, стига промяната да доведе до работеща проверка на типовете.
Основният модел на изпълнение е следният.
Функцията check е входната точка към функционалността на класа.
На свой ред, тя извиква visitProgram, с което се започва посещаването на всички елементи на АСД.
Това посещаване се изпълнява автоматично, стига да не презапишете някоя от visit функциите.
Когато го направите (ще е необходимо), е желателно да извикате отново друга visit функция, за да продължи посещаването надолу по дървото.

Всяка visit функция получава като аргумент обект от съответен Context клас.
Чрез него могат да се достъпят елементите от дясната част на кое да е правило за нетерминала.
За граматиката използвана за създаването на служебния parser, ProgramContext съдържа class\_() метод за достъп, който в този случай ще върне вектор, понеже е възможно класовете да са повече от един.
Отделните класове могат да се достъпят или чрез итериране по този вектор, или чрез свързания метод class\_(index).
ClassContext, пък, от своя страна, има методи TYPEID(), method() и attr(), всеки от които връща vector.
ClassContext съдържа и методи за достъпване на препинателните знаци\footnote{това на практика означава, че ANTLR4 генерира просто изводно дърво, а не АСД}, но те няма да са ви нужни.
За повече информация направете справка с CoolParser.h, където са дефинирани всички възможни Context класове.

Граматиката, използвана за генерирането на служебния parser тясно следва спецификацията в Бекус--Наур форма на COOL синтаксиса от Фигура 1. от ръководството за COOL, която е на страница 16.
Използвайте тази информация, за да откриете правилните индекси, когато достъпвате дъщерни възли от АСД чрез някой от методите връщащи vector.
Например, следния код проверява типовете при сбор на числа:

\begin{verbatim}
std::any TypeChecker::visitExpr(CoolParser::ExprContext *ctx) {
    if (nullptr != ctx->PLUS()) {
        return checkAddition(ctx);
    }

    // check other expressions
}
std::any TypeChecker::checkAddition(CoolParser::ExprContext *ctx) {
    Type lhs_type = any_cast<Type>(visitExpr(ctx->expr(0)));
    Type rhs_type = any_cast<Type>(visitExpr(ctx->expr(1)));

    // somehow check lhs_type and rhs_type are Int

    return int_type;
}
\end{verbatim}

\noindent Забележете използването на индекси 0 и 1 за достъпване на под-изразите, които съответстват на лявата и дясната част на сбора.

\subsection{std::any}

Генерираният ``посетител'' на АСД използва std::any като тип на върнатата стойност от всеки visit метод.
Това е механизъм, който позволява връщането на стойност от който и да е тип, стига тази стойност да бъде опакована в std::any, например така:

\begin{verbatim}
  return std::any{"hello"};
\end{verbatim}

За да използвате стойността в част от кода, която директно извиква някоя visit функция, трябва да ползвате std::any\_cast, за да я разопаковате.

\begin{verbatim}
auto message = std::any_cast<char *>(visitClass(ctx->class(0)));
\end{verbatim}

Следното е друг пример:

\begin{verbatim}
std::any visitClass(CoolParser::ClassContext *ctx) override{
  return std::any{13};
}
...
auto unfortunate = std::any_cast<int>(visitClass(ctx->class(0)));
\end{verbatim}

В случай, че се опитате да разопаковате стойност в тип, който не ѝ съответства, any\_cast ще хвърли изключение от тип std::bad\_any\_cast.
Така че, може да получите следната грешка по време на изпълнение:

\begin{verbatim}
terminate called after throwing an instance of 'std::bad_any_cast'
\end{verbatim}

\noindent Често се случва да получите тази грешка, ако се опитате да разопаковате текстов литерал като std::string. Ако искате да можете да го правите, трябва да преобразувате литерала в std::string преди да го опаковате в std::any.

\begin{verbatim}
  return std::any{std::string{"hello"}};
\end{verbatim}

За целите на семантичния анализ, бихте могли да дефинирате тип Type, който да представлява типа на израза, който да връщате опакован в std::any и да разопаковате чрез \texttt{std::any\_cast<Type>}, когато ви се наложи да го ползвате.
Вижте отново примера за checkAddition в Подраздел \ref{sec:visitor}.
Или за по-лесно, може просто вместо Type да използвате int, който да индексира типовете подред.

\subsection{CoolLexer.h}

Служебният лексикален анализатор предоставя две функции, които може да ви се наложи да ползвате.
Едната е get\_csl\_text, а другата -- get\_bool\_value.
Това което правят, е да предоставят достъп до стойностите на текстовите и булевите константи срещнати по време на лексикалния анализ.
Коментарите в CoolLexer.h би трябвало да са достатъчни, но за пълнота, ще ги добавим и тук.

Методът get\_csl\_text приема за аргумент номер на символа от входния низ, където жетонът от тип STR\_CONST започва.
Върнатата стойност е от тип std::string.
Следва примерна употреба на метода:

\begin{verbatim}
int char_index = ctx->STR_CONST()->getSymbol()->getStartIndex();
print_escaped_string(cout, lexer_->get_csl_text(char_index));
\end{verbatim}

\noindent Обърнете внимание, че тук print\_escaped\_string не е предоставена от нас функция, а такава, която вие трябва да реализирате, ако имате нужда.

За да използвате метода, трябва да го извикате върху обект от тип CoolLexer.
Този обект трябва да е CoolLexer-а, който е използван за лексикален анализ, за да съдържа исканата информация (стойността на текстовия низ срещнат по време на лексикалния анализ).
В тази извадка от програма, ctx е Context обект (виж Подраздел \ref{sec:visitor}) на нетерминал, който някъде в дясната част на правилото си има терминал от тип STR\_CONST.

Методът get\_bool\_value приема за аргумент номер на символа от входния низ, където жетонът от тип BOOL\_CONST започва.
Върнатата стойност е от тип bool.
Следва примерна употреба на метода:

\begin{verbatim}
int char_index = ctx->BOOL_CONST()->getSymbol()->getStartIndex();
cout << lexer_->get_bool_value(char_index) << endl;
\end{verbatim}

За целта, кодът, който има нужда да използва метода, трябва да има достъп до указател към обекта от тип CoolLexer, който е използван за лексикален анализ.
В тази извадка от програма, ctx е Context обект (виж Подраздел \ref{sec:visitor}) на нетерминал, който някъде в дясната част на правилото си има терминал от тип BOOL\_CONST.

\subsection{CoolParser*.h}

Служебният синтактичен анализатор дава достъп до корена на построеното от него АСД и начин то да се обходи.
Начинът, разбира се е чрез "посетител", описан в Подраздел \ref{sec:visitor}.
Файловете, в които се съдържа информация за системния синтактичен анализатор са CoolParser.h, CoolParserVisitor.h и CoolparserBaseVisitor.h.
Шаблонният код в предоставения TypeChecker.cpp демонстрира как може да се ползва системния синтактичен анализатор:

\begin{verbatim}
vector<string> TypeChecker::check(CoolParser *parser) {
    visitProgram(parser->program());
    parser->reset();

    return std::move(errors);
}
\end{verbatim}

Важно е да се извиква \texttt{parser->reset()} след всяко преминаване през АСД, за да е възможно повторно позволяване без изграждане на ново АСД, чрез повторен синтактичен анализ на входната програма.

\subsection{typed-ast}

В папките src/typed-ast и include/typed-ast е реализирана голяма част от структурата, която трябва да генерира вашият семантичен анализатор.
Това, което остава за вас, е да декларирате таблица с класове или някаква друга структура, която да съдържа самото типизирано АСД.
Повечето класове са под-типове на Expr, който също е дефиниран в typed-ast.
Това позволява написването на ``посетител'', който обхожда АСД от синтактичния анализатор и строи типизирано АСД.
Класовете, които не са под-типове на Expr, са тези, които не са изрази връщащи стойност в езика COOL---Attribute и Method и техните контейнери Attributes и Methods. За тип се ползва int, но може да промените това, ако сметнете за нужно.

За жалост, std::any не позволява опаковането на обекти, които не са ``copy constructible''.
А някои от Expr класовете в typed-ast са такива, за да притежават ексклузивно под-изразите си.
Това ограничение може да се заобиколи чрез използването на поле от класа строящ типизираното АСД, което да е от тип \texttt{std::stack<std::unique\_ptr<Expr>>}.
Така visit методите вместо да връщат Expr обекти, могат да ги слагат на този допълнителен стек.
Методите, които искат да използват резултата могат да го вземат от стека.

Например, ако стековата променлива е наречена scratchpad\_, следното е възможна реализация на част от кода изграждащ типизираното АСД:

\begin{verbatim}
any TypedAstBuilder::visitExpr(ExprContext *ctx) {
    ...
    if (nullptr != ctx->INT_CONST()) {
        // constant_value = extract from parser
        // type = Int
        scratchpad_.push(make_unique<IntConstant>(constant_value, type));
        return nullptr;
    }
    ...
    if (nullptr != ctx->PLUS()) {
        auto lhs = visitExprAndAssertOk(ctx->expr(0));
        auto rhs = visitExprAndAssertOk(ctx->expr(1));
        // kind = Arithmetic::Kind::Addition
        // type = Int
        scratchpad_.push(make_unique<Arithmetic>(move(lhs), move(rhs), kind, type));
        return nullptr;
    }
    ...
}
\end{verbatim}

Ако разгледаме кода само така, изглежда като комбинация на това което имахме преди (връщане чрез std::any) и употребата на scratchpad\_.
Тайната се крие в добавения метод visitExprAndAssertOk, който първо се уверява че стековата променлива не е празна, след което връща стойността ѝ, без да я копира:

\begin{verbatim}
unique_ptr<Expr> TypedAstBuilder::visitExprAndAssertOk(ExprContext *ctx) {
    visitExpr(ctx);

    if (scratchpad_.empty()) {
        assert(false && "ICE: scratchpad_ is empty after visitExpr, but "
                        "caller expects an Expr there");
    }

    auto expr = move(scratchpad_.top());
    scratchpad_.pop();

    return move(expr);
}
\end{verbatim}

\noindent Така употребите на visitExpr могат да се заменят с visitExprAndAssertOk и стилът да е като преди.
Единствено е нужно, когато се създават нови изрази, те да се слагат на стека scratchpad\_, вместо директно да се връщат чрез std::any.

\section{Предаване на Решение}

За да предадете решение, изпълнете ``tools/grade-semantics.sh'' в контейнера.
Този скрипт ще отпечата код за предаване, например ``1:c4ca4238a0b923820dcc509a6f75849b''.
Копирайте този код в специалния \href{https://learn.fmi.uni-sofia.bg/mod/quiz/view.php?id=362013}{формуляр за предаване в Мудъл}.
Освен това, трябва да качите и променения от вас код в специалната \href{https://learn.fmi.uni-sofia.bg/mod/publication/view.php?id=362085}{папка за предаване в Мудъл}.
Ако сте променили C++ проекта, така че да включва и други файлове, качете и тях в папката.

\end{document}
